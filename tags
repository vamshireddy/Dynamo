!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Accept	csapp.c	/^int Accept(int s, struct sockaddr *addr, socklen_t *addrlen)$/;"	f
Alarm	csapp.c	/^unsigned int Alarm(unsigned int seconds) {$/;"	f
Bind	csapp.c	/^void Bind(int sockfd, struct sockaddr *my_addr, int addrlen)$/;"	f
Calloc	csapp.c	/^void *Calloc(size_t nmemb, size_t size)$/;"	f
Close	csapp.c	/^void Close(int fd)$/;"	f
Closedir	csapp.c	/^int Closedir(DIR *dirp)$/;"	f
Connect	csapp.c	/^void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen)$/;"	f
DEBUG	util.h	11;"	d
DEFAULT_LISTEN_PORT	server.c	21;"	d	file:
DEFAULT_LISTEN_PORT	server_unopt.c	23;"	d	file:
DEF_MODE	csapp.h	34;"	d
DEF_UMASK	csapp.h	35;"	d
Dup2	csapp.c	/^int Dup2(int fd1, int fd2)$/;"	f
EVENT_OWNER_CLIENT	util.h	6;"	d
EVENT_OWNER_WORKER	util.h	7;"	d
Execve	csapp.c	/^void Execve(const char *filename, char *const argv[], char *const envp[])$/;"	f
Fclose	csapp.c	/^void Fclose(FILE *fp)$/;"	f
Fdopen	csapp.c	/^FILE *Fdopen(int fd, const char *type)$/;"	f
Fgets	csapp.c	/^char *Fgets(char *ptr, int n, FILE *stream)$/;"	f
Fopen	csapp.c	/^FILE *Fopen(const char *filename, const char *mode)$/;"	f
Fork	csapp.c	/^pid_t Fork(void)$/;"	f
Fputs	csapp.c	/^void Fputs(const char *ptr, FILE *stream)$/;"	f
Fread	csapp.c	/^size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream)$/;"	f
Free	csapp.c	/^void Free(void *ptr)$/;"	f
Freeaddrinfo	csapp.c	/^void Freeaddrinfo(struct addrinfo *res)$/;"	f
Fstat	csapp.c	/^void Fstat(int fd, struct stat *buf)$/;"	f
Fwrite	csapp.c	/^void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)$/;"	f
Getaddrinfo	csapp.c	/^void Getaddrinfo(const char *node, const char *service,$/;"	f
Gethostbyaddr	csapp.c	/^struct hostent *Gethostbyaddr(const char *addr, int len, int type)$/;"	f
Gethostbyname	csapp.c	/^struct hostent *Gethostbyname(const char *name)$/;"	f
Getnameinfo	csapp.c	/^void Getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host,$/;"	f
Getpgrp	csapp.c	/^pid_t Getpgrp(void) {$/;"	f
HTTP_200	http.h	12;"	d
HTTP_404	http.h	13;"	d
HTTP_ERR_CODE_BAD_REQUEST	http_header.h	29;"	d
HTTP_ERR_CODE_METHOD_NOT_ALLOWED	http_header.h	30;"	d
HTTP_ERR_HEADER_KEY_VALUE_INVALID	http_header.h	24;"	d
HTTP_HEADER_PROXY_H	http_header.h	2;"	d
HTTP_INVALID_PROTOCOL	http_header.h	26;"	d
HTTP_INVALID_REQUEST	http_header.h	23;"	d
HTTP_PARSE_ERROR	http_header.h	25;"	d
HTTP_PROTO_H	http.h	2;"	d
HTTP_REQ_TYPE_NOT_SUPPORTED	http_header.h	21;"	d
HTTP_VERSION_NOT_SUPPORTED	http_header.h	22;"	d
Inet_ntop	csapp.c	/^void Inet_ntop(int af, const void *src, char *dst, socklen_t size)$/;"	f
Inet_pton	csapp.c	/^void Inet_pton(int af, const char *src, void *dst)$/;"	f
Kill	csapp.c	/^void Kill(pid_t pid, int signum)$/;"	f
LISTENQ	csapp.h	61;"	d
Listen	csapp.c	/^void Listen(int s, int backlog)$/;"	f
Lseek	csapp.c	/^off_t Lseek(int fildes, off_t offset, int whence)$/;"	f
MAXBUF	csapp.h	60;"	d
MAXLINE	csapp.h	59;"	d
MAX_DLL_NAME_LENGTH	dynlib_cache.h	3;"	d
MAX_DLL_PATH_LENGTH	dynlib_cache.h	4;"	d
MAX_EPOLL_EVENTS	server.c	25;"	d	file:
MAX_ERROR_MSG_LENGTH	http_header.h	33;"	d
MAX_FD_LIMIT	server.c	24;"	d	file:
MAX_FD_LIMIT	server_unopt.c	27;"	d	file:
MAX_HEADERS_TOTAL_LENGTH	http_header.h	17;"	d
MAX_HEADER_KEY_LENGTH	http_header.h	11;"	d
MAX_HEADER_VALUE_LENGTH	http_header.h	12;"	d
MAX_HTTP_VERSION_LENGTH	http_header.h	14;"	d
MAX_LISTEN_QUEUE	server.c	22;"	d	file:
MAX_LISTEN_QUEUE	server_unopt.c	24;"	d	file:
MAX_NAME_LENGTH	server.c	23;"	d	file:
MAX_NAME_LENGTH	server_unopt.c	25;"	d	file:
MAX_READLINE_STR_LENGTH	http_header.h	36;"	d
MAX_READ_LENGTH	server.c	20;"	d	file:
MAX_READ_LENGTH	server_unopt.c	26;"	d	file:
MAX_REQUEST_TYPE_LENGTH	http_header.h	13;"	d
MAX_URL_LENGTH	http_header.h	5;"	d
Malloc	csapp.c	/^void *Malloc(size_t size)$/;"	f
Mmap	csapp.c	/^void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)$/;"	f
Munmap	csapp.c	/^void Munmap(void *start, size_t length)$/;"	f
Open	csapp.c	/^int Open(const char *pathname, int flags, mode_t mode)$/;"	f
Open_clientfd	csapp.c	/^int Open_clientfd(char *hostname, char *port)$/;"	f
Open_listenfd	csapp.c	/^int Open_listenfd(char *port)$/;"	f
Opendir	csapp.c	/^DIR *Opendir(const char *name)$/;"	f
P	csapp.c	/^void P(sem_t *sem)$/;"	f
PORT_NUMBER_STR_MAX_LENGTH	http_header.h	8;"	d
Pause	csapp.c	/^void Pause()$/;"	f
Pthread_cancel	csapp.c	/^void Pthread_cancel(pthread_t tid) {$/;"	f
Pthread_create	csapp.c	/^void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp,$/;"	f
Pthread_detach	csapp.c	/^void Pthread_detach(pthread_t tid) {$/;"	f
Pthread_exit	csapp.c	/^void Pthread_exit(void *retval) {$/;"	f
Pthread_join	csapp.c	/^void Pthread_join(pthread_t tid, void **thread_return) {$/;"	f
Pthread_once	csapp.c	/^void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {$/;"	f
Pthread_self	csapp.c	/^pthread_t Pthread_self(void) {$/;"	f
REQUEST_TYPE_DYNAMIC_CONTENT	util.h	28;"	d
REQUEST_TYPE_STATIC_CONTENT	util.h	29;"	d
RESOURCE_TYPE_CGI_BIN	http.h	5;"	d
RESOURCE_TYPE_GIF	http.h	7;"	d
RESOURCE_TYPE_HTML	http.h	6;"	d
RESOURCE_TYPE_JPG	http.h	9;"	d
RESOURCE_TYPE_TXT	http.h	8;"	d
RESOURCE_TYPE_UNKNOWN	http.h	10;"	d
RESPONSE_HANDLING_COMPLETE	server.c	29;"	d	file:
RESPONSE_HANDLING_PARTIAL	server.c	30;"	d	file:
RIO_BUFSIZE	csapp.h	45;"	d
Read	csapp.c	/^ssize_t Read(int fd, void *buf, size_t count)$/;"	f
Readdir	csapp.c	/^struct dirent *Readdir(DIR *dirp)$/;"	f
Realloc	csapp.c	/^void *Realloc(void *ptr, size_t size)$/;"	f
Rio_readinitb	csapp.c	/^void Rio_readinitb(rio_t *rp, int fd)$/;"	f
Rio_readlineb	csapp.c	/^ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)$/;"	f
Rio_readn	csapp.c	/^ssize_t Rio_readn(int fd, void *ptr, size_t nbytes)$/;"	f
Rio_readnb	csapp.c	/^ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n)$/;"	f
Rio_writen	csapp.c	/^void Rio_writen(int fd, void *usrbuf, size_t n)$/;"	f
SA	csapp.h	/^typedef struct sockaddr SA;$/;"	t	typeref:struct:sockaddr
STRINGIFY	http_header.h	41;"	d
STRINGIFY2	http_header.h	40;"	d
STR_FMTB	http_header.h	43;"	d
SUCCESS	http_header.h	20;"	d
Select	csapp.c	/^int Select(int  n, fd_set *readfds, fd_set *writefds,$/;"	f
Sem_init	csapp.c	/^void Sem_init(sem_t *sem, int pshared, unsigned int value)$/;"	f
Setpgid	csapp.c	/^void Setpgid(pid_t pid, pid_t pgid) {$/;"	f
Setsockopt	csapp.c	/^void Setsockopt(int s, int level, int optname, const void *optval, int optlen)$/;"	f
Sigaddset	csapp.c	/^void Sigaddset(sigset_t *set, int signum)$/;"	f
Sigdelset	csapp.c	/^void Sigdelset(sigset_t *set, int signum)$/;"	f
Sigemptyset	csapp.c	/^void Sigemptyset(sigset_t *set)$/;"	f
Sigfillset	csapp.c	/^void Sigfillset(sigset_t *set)$/;"	f
Sigismember	csapp.c	/^int Sigismember(const sigset_t *set, int signum)$/;"	f
Signal	csapp.c	/^handler_t *Signal(int signum, handler_t *handler)$/;"	f
Sigprocmask	csapp.c	/^void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)$/;"	f
Sigsuspend	csapp.c	/^int Sigsuspend(const sigset_t *set)$/;"	f
Sio_error	csapp.c	/^void Sio_error(char s[])$/;"	f
Sio_putl	csapp.c	/^ssize_t Sio_putl(long v)$/;"	f
Sio_puts	csapp.c	/^ssize_t Sio_puts(char s[])$/;"	f
Sleep	csapp.c	/^unsigned int Sleep(unsigned int secs)$/;"	f
Socket	csapp.c	/^int Socket(int domain, int type, int protocol)$/;"	f
Stat	csapp.c	/^void Stat(const char *filename, struct stat *buf)$/;"	f
TRUE	server.c	18;"	d	file:
UTIL_H	util.h	4;"	d
V	csapp.c	/^void V(sem_t *sem)$/;"	f
WORKER_THREAD_COUNT	server.c	27;"	d	file:
WORKER_THREAD_PORT	util.h	9;"	d
Wait	csapp.c	/^pid_t Wait(int *status)$/;"	f
Waitpid	csapp.c	/^pid_t Waitpid(pid_t pid, int *iptr, int options)$/;"	f
Write	csapp.c	/^ssize_t Write(int fd, const void *buf, size_t count)$/;"	f
__CSAPP_H__	csapp.h	6;"	d
add_client_fd_to_epoll	util.c	/^void add_client_fd_to_epoll(int epollfd, int cli_fd)$/;"	f
add_new_header_item	http_header.c	/^void add_new_header_item(http_header_t* http_header, header_kv_pair_t* hdr)$/;"	f
add_worker_fd_to_epoll	util.c	/^void add_worker_fd_to_epoll(int epollfd, int worker_fd, int cli_fd)$/;"	f
app_error	csapp.c	/^void app_error(char *msg) \/* Application error *\/$/;"	f
cgi_function	cgi-bin/time.c	/^void cgi_function(int fd)$/;"	f
client_fd	util.h	/^    int client_fd;$/;"	m	struct:epoll_conn_state
client_handler	server_unopt.c	/^void* client_handler(void* arg)$/;"	f
connection	http_header.h	/^    char connection[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
create_listen_tcp_socket	util.c	/^int create_listen_tcp_socket(int port, int backlog, int socket_shared)$/;"	f
create_request_item	util.c	/^request_item* create_request_item(int type, char* url)$/;"	f
create_worker_threads	util.c	/^int create_worker_threads(int no_threads, void (*func)(void*))$/;"	f
dbg_printf	server_unopt.c	31;"	d	file:
dbg_printf	server_unopt.c	33;"	d	file:
dbg_printf	util.h	14;"	d
dbg_printf	util.h	16;"	d
dns_error	csapp.c	/^void dns_error(char *msg) \/* Obsolete gethostbyname error *\/$/;"	f
dynlib_cache	dynlib_cache.h	/^struct dynlib_cache$/;"	s
epoll_conn_state	util.h	/^typedef struct epoll_conn_state$/;"	s
epoll_conn_state	util.h	/^}epoll_conn_state;$/;"	t	typeref:struct:epoll_conn_state
file_name	dynlib_cache.h	/^    char file_name[MAX_DLL_NAME_LENGTH];$/;"	m	struct:dynlib_cache
free_kvpairs_in_header	http_header.c	/^void free_kvpairs_in_header(http_header_t* header)$/;"	f
gai_error	csapp.c	/^void gai_error(int code, char *msg) \/* Getaddrinfo-style error *\/$/;"	f
get_resource_type	http.c	/^int get_resource_type(char* url, char* resource_name)$/;"	f
handle_client_request	server.c	/^void handle_client_request(int epollfd, epoll_conn_state* con)$/;"	f
handle_client_response	server.c	/^int handle_client_response(int epollfd, epoll_conn_state* con)$/;"	f
handle_dynamic	server_unopt.c	/^void handle_dynamic(int fd, char* resource_name)$/;"	f
handle_static	server_unopt.c	/^void handle_static(int fd, char* resource_name)$/;"	f
handle_unknown	server_unopt.c	/^void handle_unknown(int fd, char* resource_name)$/;"	f
handler_t	csapp.h	/^typedef void handler_t(int);$/;"	t
header_key_value	http_header.h	/^typedef struct header_key_value$/;"	s
header_kv_pair_t	http_header.h	/^}header_kv_pair_t;$/;"	t	typeref:struct:header_key_value
host	http_header.h	/^    char host[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
http_header	http_header.h	/^typedef struct http_header$/;"	s
http_header_t	http_header.h	/^}http_header_t;$/;"	t	typeref:struct:http_header
http_scan_header	http.c	/^int http_scan_header(int clientfd, http_header_t* header)$/;"	f
http_write_response_header	http.c	/^int http_write_response_header(int clientfd, int http_response_code)$/;"	f
increase_fd_limit	util.c	/^int increase_fd_limit(int max_fds)$/;"	f
init_header	http_header.c	/^void init_header(http_header_t* header)$/;"	f
key	http_header.h	/^    char key[MAX_HEADER_KEY_LENGTH];$/;"	m	struct:header_key_value
load_dyn_library	dynlib_cache.c	/^void* load_dyn_library(char* library_name)$/;"	f
main	hey.c	/^int main()$/;"	f
main	server.c	/^int main(int argc, char *argv[])$/;"	f
main	server_unopt.c	/^int main(int argc, char *argv[])$/;"	f
make_socket_non_blocking	util.c	/^int make_socket_non_blocking (int sfd)$/;"	f
next	dynlib_cache.h	/^    struct dynlib_cache* next;$/;"	m	struct:dynlib_cache	typeref:struct:dynlib_cache::dynlib_cache
next	http_header.h	/^    struct header_key_value* next;$/;"	m	struct:header_key_value	typeref:struct:header_key_value::header_key_value
open_clientfd	csapp.c	/^int open_clientfd(char *hostname, char *port) {$/;"	f
open_listenfd	csapp.c	/^int open_listenfd(char *port)$/;"	f
other_headers	http_header.h	/^    header_kv_pair_t *other_headers;$/;"	m	struct:http_header
parse_port_number	util.c	/^int parse_port_number(int argc, char* argv)$/;"	f
posix_error	csapp.c	/^void posix_error(int code, char *msg) \/* Posix-style error *\/$/;"	f
proxy_connection	http_header.h	/^    char proxy_connection[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
request_http_version	http_header.h	/^    char request_http_version[MAX_HTTP_VERSION_LENGTH]; \/* HTTP\/1.1, HTTP\/1.0 *\/$/;"	m	struct:http_header
request_item	util.h	/^typedef struct request_item$/;"	s
request_item	util.h	/^}request_item;$/;"	t	typeref:struct:request_item
request_type	http_header.h	/^    char request_type[MAX_REQUEST_TYPE_LENGTH]; \/* GET *\/$/;"	m	struct:http_header
request_type	util.h	/^    int request_type;$/;"	m	struct:request_item
request_url	http_header.h	/^    char request_url[MAX_URL_LENGTH]; \/* \/, \/index.html, etc *\/$/;"	m	struct:http_header
resource_url	util.h	/^    char resource_url[MAX_URL_LENGTH];$/;"	m	struct:request_item
rio_buf	csapp.h	/^    char rio_buf[RIO_BUFSIZE]; \/* Internal buffer *\/$/;"	m	struct:__anon1
rio_bufptr	csapp.h	/^    char *rio_bufptr;          \/* Next unread byte in internal buf *\/$/;"	m	struct:__anon1
rio_cnt	csapp.h	/^    int rio_cnt;               \/* Unread bytes in internal buf *\/$/;"	m	struct:__anon1
rio_fd	csapp.h	/^    int rio_fd;                \/* Descriptor for this internal buf *\/$/;"	m	struct:__anon1
rio_read	csapp.c	/^static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readinitb	csapp.c	/^void rio_readinitb(rio_t *rp, int fd)$/;"	f
rio_readlineb	csapp.c	/^ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)$/;"	f
rio_readn	csapp.c	/^ssize_t rio_readn(int fd, void *usrbuf, size_t n)$/;"	f
rio_readnb	csapp.c	/^ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)$/;"	f
rio_t	csapp.h	/^} rio_t;$/;"	t	typeref:struct:__anon1
rio_writen	csapp.c	/^ssize_t rio_writen(int fd, void *usrbuf, size_t n)$/;"	f
send_to_worker_thread	util.c	/^int send_to_worker_thread(request_item* reqitem)$/;"	f
sio_error	csapp.c	/^void sio_error(char s[]) \/* Put error message and exit *\/$/;"	f
sio_ltoa	csapp.c	/^static void sio_ltoa(long v, char s[], int b)$/;"	f	file:
sio_putl	csapp.c	/^ssize_t sio_putl(long v) \/* Put long *\/$/;"	f
sio_puts	csapp.c	/^ssize_t sio_puts(char s[]) \/* Put string *\/$/;"	f
sio_reverse	csapp.c	/^static void sio_reverse(char s[])$/;"	f	file:
sio_strlen	csapp.c	/^static size_t sio_strlen(char s[])$/;"	f	file:
size	dynlib_cache.h	/^    int size;$/;"	m	struct:dynlib_cache
type	util.h	/^    int type; \/* Who is handling this state *\/$/;"	m	struct:epoll_conn_state
unix_error	csapp.c	/^void unix_error(char *msg) \/* Unix-style error *\/$/;"	f
unload_dyn_library	dynlib_cache.c	/^int unload_dyn_library(void* handle)$/;"	f
user_agent	http_header.h	/^    char user_agent[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
value	http_header.h	/^    char value[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:header_key_value
worker_fd	util.h	/^    int worker_fd;$/;"	m	struct:epoll_conn_state
worker_thread	server.c	/^void worker_thread(void* arg)$/;"	f
