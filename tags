!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Accept	csapp.c	/^int Accept(int s, struct sockaddr *addr, socklen_t *addrlen)$/;"	f
Achievements	static/vamshi.html	/^<h2><a name="Achievements">Achievements<\/a><\/h2>$/;"	a
Alarm	csapp.c	/^unsigned int Alarm(unsigned int seconds) {$/;"	f
Bind	csapp.c	/^void Bind(int sockfd, struct sockaddr *my_addr, int addrlen)$/;"	f
CACHE_DELETE_ERR	cache.h	17;"	d
CACHE_DELETE_SUCCESS	cache.h	19;"	d
CACHE_INSERT_ERR	cache.h	16;"	d
CACHE_INSERT_SUCCESS	cache.h	18;"	d
CGIBIN_DIR_NAME	util.h	22;"	d
Calloc	csapp.c	/^void *Calloc(size_t nmemb, size_t size)$/;"	f
Close	csapp.c	/^void Close(int fd)$/;"	f
Closedir	csapp.c	/^int Closedir(DIR *dirp)$/;"	f
Connect	csapp.c	/^void Connect(int sockfd, struct sockaddr *serv_addr, int addrlen)$/;"	f
Courses	static/vamshi.html	/^<h2><a name="Courses">Online Courses<\/a><\/h2>$/;"	a
DEFAULT_LISTEN_PORT	server.c	35;"	d	file:
DEFAULT_LISTEN_PORT	server_unopt.c	24;"	d	file:
DEF_MODE	csapp.h	34;"	d
DEF_UMASK	csapp.h	35;"	d
Dup2	csapp.c	/^int Dup2(int fd1, int fd2)$/;"	f
EVENT_OWNER_CLIENT	util.h	10;"	d
EVENT_OWNER_WORKER	util.h	11;"	d
Execve	csapp.c	/^void Execve(const char *filename, char *const argv[], char *const envp[])$/;"	f
Fclose	csapp.c	/^void Fclose(FILE *fp)$/;"	f
Fdopen	csapp.c	/^FILE *Fdopen(int fd, const char *type)$/;"	f
Fgets	csapp.c	/^char *Fgets(char *ptr, int n, FILE *stream)$/;"	f
Fopen	csapp.c	/^FILE *Fopen(const char *filename, const char *mode)$/;"	f
Fork	csapp.c	/^pid_t Fork(void)$/;"	f
Fputs	csapp.c	/^void Fputs(const char *ptr, FILE *stream)$/;"	f
Fread	csapp.c	/^size_t Fread(void *ptr, size_t size, size_t nmemb, FILE *stream)$/;"	f
Free	csapp.c	/^void Free(void *ptr)$/;"	f
Freeaddrinfo	csapp.c	/^void Freeaddrinfo(struct addrinfo *res)$/;"	f
Fstat	csapp.c	/^void Fstat(int fd, struct stat *buf)$/;"	f
Fwrite	csapp.c	/^void Fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)$/;"	f
Getaddrinfo	csapp.c	/^void Getaddrinfo(const char *node, const char *service,$/;"	f
Gethostbyaddr	csapp.c	/^struct hostent *Gethostbyaddr(const char *addr, int len, int type)$/;"	f
Gethostbyname	csapp.c	/^struct hostent *Gethostbyname(const char *name)$/;"	f
Getnameinfo	csapp.c	/^void Getnameinfo(const struct sockaddr *sa, socklen_t salen, char *host,$/;"	f
Getpgrp	csapp.c	/^pid_t Getpgrp(void) {$/;"	f
HTTP_200	http_util.h	13;"	d
HTTP_404	http_util.h	14;"	d
HTTP_ERR_CODE_BAD_REQUEST	http_header.h	26;"	d
HTTP_ERR_CODE_METHOD_NOT_ALLOWED	http_header.h	27;"	d
HTTP_ERR_HEADER_KEY_VALUE_INVALID	http_header.h	21;"	d
HTTP_INVALID_PROTOCOL	http_header.h	23;"	d
HTTP_INVALID_REQUEST	http_header.h	20;"	d
HTTP_PARSE_ERROR	http_header.h	22;"	d
HTTP_REQ_TYPE_NOT_SUPPORTED	http_header.h	18;"	d
HTTP_VERSION_NOT_SUPPORTED	http_header.h	19;"	d
Inet_ntop	csapp.c	/^void Inet_ntop(int af, const void *src, char *dst, socklen_t size)$/;"	f
Inet_pton	csapp.c	/^void Inet_pton(int af, const char *src, void *dst)$/;"	f
Kill	csapp.c	/^void Kill(pid_t pid, int signum)$/;"	f
LISTENQ	csapp.h	61;"	d
Listen	csapp.c	/^void Listen(int s, int backlog)$/;"	f
Lseek	csapp.c	/^off_t Lseek(int fildes, off_t offset, int whence)$/;"	f
MAXBUF	csapp.h	60;"	d
MAXLINE	csapp.h	59;"	d
MAX_CACHE_SIZE	cache.h	15;"	d
MAX_DLL_NAME_LENGTH	util.h	27;"	d
MAX_DLL_PATH_LENGTH	util.h	28;"	d
MAX_EPOLL_EVENTS	server.c	38;"	d	file:
MAX_ERROR_MSG_LENGTH	http_header.h	30;"	d
MAX_FD_LIMIT	server.c	37;"	d	file:
MAX_FD_LIMIT	server_unopt.c	28;"	d	file:
MAX_HEADERS_TOTAL_LENGTH	http_header.h	14;"	d
MAX_HEADER_KEY_LENGTH	http_header.h	8;"	d
MAX_HEADER_VALUE_LENGTH	http_header.h	9;"	d
MAX_HTTP_VERSION_LENGTH	http_header.h	11;"	d
MAX_KEY_LENGTH	cache.h	20;"	d
MAX_LISTEN_QUEUE	server.c	36;"	d	file:
MAX_LISTEN_QUEUE	server_unopt.c	25;"	d	file:
MAX_NAME_LENGTH	server_unopt.c	26;"	d	file:
MAX_PATH_CHARS	util.h	19;"	d
MAX_READLINE_STR_LENGTH	http_header.h	33;"	d
MAX_READ_LENGTH	server_unopt.c	27;"	d	file:
MAX_READ_LENGTH	util.h	24;"	d
MAX_REQUEST_TYPE_LENGTH	http_header.h	10;"	d
MAX_RESOURCE_NAME_LENGTH	util.h	13;"	d
MAX_URL_LENGTH	http_header.h	4;"	d
Malloc	csapp.c	/^void *Malloc(size_t size)$/;"	f
Mmap	csapp.c	/^void *Mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)$/;"	f
Munmap	csapp.c	/^void Munmap(void *start, size_t length)$/;"	f
NON_SHARED_SOCKET	util.h	35;"	d
Open	csapp.c	/^int Open(const char *pathname, int flags, mode_t mode)$/;"	f
Open_clientfd	csapp.c	/^int Open_clientfd(char *hostname, char *port)$/;"	f
Open_listenfd	csapp.c	/^int Open_listenfd(char *port)$/;"	f
Opendir	csapp.c	/^DIR *Opendir(const char *name)$/;"	f
P	csapp.c	/^void P(sem_t *sem)$/;"	f
PORT_NUMBER_STR_MAX_LENGTH	http_header.h	5;"	d
PROXY_CACHE_H	cache.h	7;"	d
Pause	csapp.c	/^void Pause()$/;"	f
Pthread_cancel	csapp.c	/^void Pthread_cancel(pthread_t tid) {$/;"	f
Pthread_create	csapp.c	/^void Pthread_create(pthread_t *tidp, pthread_attr_t *attrp,$/;"	f
Pthread_detach	csapp.c	/^void Pthread_detach(pthread_t tid) {$/;"	f
Pthread_exit	csapp.c	/^void Pthread_exit(void *retval) {$/;"	f
Pthread_join	csapp.c	/^void Pthread_join(pthread_t tid, void **thread_return) {$/;"	f
Pthread_once	csapp.c	/^void Pthread_once(pthread_once_t *once_control, void (*init_function)()) {$/;"	f
Pthread_rwlock_rdlock	util.c	/^void Pthread_rwlock_rdlock(pthread_rwlock_t* lock)$/;"	f
Pthread_rwlock_unlock	util.c	/^void Pthread_rwlock_unlock(pthread_rwlock_t* lock)$/;"	f
Pthread_rwlock_wrlock	util.c	/^void Pthread_rwlock_wrlock(pthread_rwlock_t* lock)$/;"	f
Pthread_self	csapp.c	/^pthread_t Pthread_self(void) {$/;"	f
RESOURCE_TYPE_CGI_BIN	http_util.h	5;"	d
RESOURCE_TYPE_GIF	http_util.h	7;"	d
RESOURCE_TYPE_HTML	http_util.h	6;"	d
RESOURCE_TYPE_JPG	http_util.h	9;"	d
RESOURCE_TYPE_TXT	http_util.h	8;"	d
RESOURCE_TYPE_UNKNOWN	http_util.h	10;"	d
RESPONSE_HANDLING_COMPLETE	util.h	30;"	d
RESPONSE_HANDLING_PARTIAL	util.h	31;"	d
RIO_BUFSIZE	csapp.h	45;"	d
Read	csapp.c	/^ssize_t Read(int fd, void *buf, size_t count)$/;"	f
Readdir	csapp.c	/^struct dirent *Readdir(DIR *dirp)$/;"	f
Realloc	csapp.c	/^void *Realloc(void *ptr, size_t size)$/;"	f
Research	static/vamshi.html	/^<h2 style="font-size:300%;"><a name="Research">Research<\/a><\/h2>$/;"	a
Rio_readinitb	csapp.c	/^void Rio_readinitb(rio_t *rp, int fd)$/;"	f
Rio_readlineb	csapp.c	/^ssize_t Rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)$/;"	f
Rio_readn	csapp.c	/^ssize_t Rio_readn(int fd, void *ptr, size_t nbytes)$/;"	f
Rio_readnb	csapp.c	/^ssize_t Rio_readnb(rio_t *rp, void *usrbuf, size_t n)$/;"	f
Rio_writen	csapp.c	/^void Rio_writen(int fd, void *usrbuf, size_t n)$/;"	f
SA	csapp.h	/^typedef struct sockaddr SA;$/;"	t	typeref:struct:sockaddr
SERVER_REQUIRED_CMD_ARG_COUNT	util.h	37;"	d
SHARED_SOCKET	util.h	34;"	d
STATIC_DIR_NAME	util.h	23;"	d
STAT_INTERVAL	util.h	8;"	d
STRINGIFY	http_header.h	38;"	d
STRINGIFY2	http_header.h	37;"	d
STR_FMTB	http_header.h	40;"	d
SUCCESS	http_header.h	17;"	d
Select	csapp.c	/^int Select(int  n, fd_set *readfds, fd_set *writefds,$/;"	f
Sem_init	csapp.c	/^void Sem_init(sem_t *sem, int pshared, unsigned int value)$/;"	f
Setpgid	csapp.c	/^void Setpgid(pid_t pid, pid_t pgid) {$/;"	f
Setsockopt	csapp.c	/^void Setsockopt(int s, int level, int optname, const void *optval, int optlen)$/;"	f
Sigaddset	csapp.c	/^void Sigaddset(sigset_t *set, int signum)$/;"	f
Sigdelset	csapp.c	/^void Sigdelset(sigset_t *set, int signum)$/;"	f
Sigemptyset	csapp.c	/^void Sigemptyset(sigset_t *set)$/;"	f
Sigfillset	csapp.c	/^void Sigfillset(sigset_t *set)$/;"	f
Sigismember	csapp.c	/^int Sigismember(const sigset_t *set, int signum)$/;"	f
Signal	csapp.c	/^handler_t *Signal(int signum, handler_t *handler)$/;"	f
Sigprocmask	csapp.c	/^void Sigprocmask(int how, const sigset_t *set, sigset_t *oldset)$/;"	f
Sigsuspend	csapp.c	/^int Sigsuspend(const sigset_t *set)$/;"	f
Sio_error	csapp.c	/^void Sio_error(char s[])$/;"	f
Sio_putl	csapp.c	/^ssize_t Sio_putl(long v)$/;"	f
Sio_puts	csapp.c	/^ssize_t Sio_puts(char s[])$/;"	f
Sleep	csapp.c	/^unsigned int Sleep(unsigned int secs)$/;"	f
Socket	csapp.c	/^int Socket(int domain, int type, int protocol)$/;"	f
Stat	csapp.c	/^void Stat(const char *filename, struct stat *buf)$/;"	f
V	csapp.c	/^void V(sem_t *sem)$/;"	f
WORKER_THREAD_COUNT	server.c	43;"	d	file:
WORKER_THREAD_PORT	util.h	14;"	d
Wait	csapp.c	/^pid_t Wait(int *status)$/;"	f
Waitpid	csapp.c	/^pid_t Waitpid(pid_t pid, int *iptr, int options)$/;"	f
Write	csapp.c	/^ssize_t Write(int fd, const void *buf, size_t count)$/;"	f
__CSAPP_H__	csapp.h	6;"	d
__DYBLIB_H	dynlib.h	2;"	d
__HTTP_HEADER_PROXY_H	http_header.h	2;"	d
__HTTP_PROTO_H	http_util.h	2;"	d
__UTIL_H	util.h	2;"	d
add_client_fd_to_epoll	util.c	/^void add_client_fd_to_epoll(int epollfd, int cli_fd)$/;"	f
add_new_header_item	http_header.c	/^void add_new_header_item(http_header_t* http_header, header_kv_pair_t* hdr)$/;"	f
add_to_cache	cache.c	/^int add_to_cache(cache_t* cache, cache_entry_t* entry)$/;"	f
add_worker_fd_to_epoll	util.c	/^void add_worker_fd_to_epoll(int epollfd, int worker_fd, epoll_conn_state* cli_con)$/;"	f
app_error	csapp.c	/^void app_error(char *msg) \/* Application error *\/$/;"	f
cache	cache.h	/^typedef struct cache$/;"	s
cache	util.c	/^static cache_t* cache;$/;"	v	file:
cache_data_item	cache.h	/^typedef struct cache_data_item$/;"	s
cache_data_item_t	cache.h	/^}cache_data_item_t;$/;"	t	typeref:struct:cache_data_item
cache_entry	cache.h	/^typedef struct cache_entry$/;"	s
cache_entry_t	cache.h	/^}cache_entry_t;$/;"	t	typeref:struct:cache_entry
cache_key	cache.h	/^typedef struct cache_key$/;"	s
cache_key_t	cache.h	/^}cache_key_t;$/;"	t	typeref:struct:cache_key
cache_t	cache.h	/^}cache_t;$/;"	t	typeref:struct:cache
cache_value	cache.h	/^typedef struct cache_value$/;"	s
cache_value_t	cache.h	/^}cache_value_t;$/;"	t	typeref:struct:cache_value
cgi_function	cgi-bin/src/hash.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/hello.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/lengthy.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/long_long.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/random.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/really_big.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/really_long.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/string.c	/^int cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/time.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/time1.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/time_long.c	/^void cgi_function(int fd)$/;"	f
cgi_function	cgi-bin/src/time_really_long.c	/^void cgi_function(int fd)$/;"	f
client_con	util.h	/^    struct epoll_conn_state* client_con;$/;"	m	struct:epoll_conn_state	typeref:struct:epoll_conn_state::epoll_conn_state
client_fd	util.h	/^    int client_fd; \/* Required to perform sendfile directly for STATIC request type*\/$/;"	m	struct:request_item
client_fd	util.h	/^    int client_fd;$/;"	m	struct:epoll_conn_state
client_handler	server_unopt.c	/^void* client_handler(void* arg)$/;"	f
connection	http_header.h	/^    char connection[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
create_dynamic_request_item	util.c	/^request_item* create_dynamic_request_item(char* name)$/;"	f
create_listen_tcp_socket	util.c	/^int create_listen_tcp_socket(int port, int backlog, int socket_shared)$/;"	f
create_stat_thread	util.c	/^void create_stat_thread()$/;"	f
create_static_request_item	util.c	/^request_item* create_static_request_item(char* name, int client_fd)$/;"	f
create_static_worker	util.c	/^void create_static_worker(int client_fd, void* (*func)(void*), char* res_name)$/;"	f
create_threads	util.c	/^int create_threads(int no_threads, void* (*func)(void*))$/;"	f
data	cache.h	/^    cache_data_item_t* data;$/;"	m	struct:cache_entry
data_size	cache.h	/^    int data_size;$/;"	m	struct:cache_entry
dbg_printf	server_unopt.c	31;"	d	file:
dbg_printf	server_unopt.c	33;"	d	file:
dbg_printf	util.h	40;"	d
dbg_printf	util.h	42;"	d
delete_callback	cache.h	/^    void (*delete_callback)(cache_data_item_t*);$/;"	m	struct:cache_entry
delete_lru_entry	cache.c	/^int delete_lru_entry(cache_t* cache)$/;"	f
display_cache	cache.c	/^void display_cache(cache_t* cache)$/;"	f
dns_error	csapp.c	/^void dns_error(char *msg) \/* Obsolete gethostbyname error *\/$/;"	f
dynamic_content_worker_thread	server.c	/^void* dynamic_content_worker_thread(void* arg)$/;"	f
dynamic_lib_mutex	util.c	/^static pthread_mutex_t dynamic_lib_mutex;$/;"	v	file:
epoll_conn_state	util.h	/^typedef struct epoll_conn_state$/;"	s
epoll_conn_state	util.h	/^}epoll_conn_state;$/;"	t	typeref:struct:epoll_conn_state
experience	static/vamshi.html	/^<h2><a name="experience">Experience<\/a><\/h2>$/;"	a
free_cache_entry	cache.c	/^void free_cache_entry(cache_entry_t* entry)$/;"	f
free_kvpairs_in_header	http_header.c	/^void free_kvpairs_in_header(http_header_t* header)$/;"	f
gai_error	csapp.c	/^void gai_error(int code, char *msg) \/* Getaddrinfo-style error *\/$/;"	f
get_cached_data	cache.c	/^cache_data_item_t* get_cached_data(cache_t* cache, cache_key_t* key)$/;"	f
get_new_cache	cache.c	/^cache_t* get_new_cache()$/;"	f
get_new_cache_entry	cache.c	/^cache_entry_t* get_new_cache_entry()$/;"	f
get_reply_count	util.c	/^long get_reply_count()$/;"	f
get_request_count	util.c	/^long get_request_count()$/;"	f
get_resource_type	http_util.c	/^int get_resource_type(char* url, char* resource_name)$/;"	f
handle_client_request	server.c	/^void handle_client_request(int epollfd, epoll_conn_state* con)$/;"	f
handle_client_response	server.c	/^int handle_client_response(int epollfd, epoll_conn_state* con)$/;"	f
handle_dynamic	server_unopt.c	/^static void handle_dynamic(int fd, char* resource_name)$/;"	f	file:
handle_dynamic_exec_lib	util.c	/^void handle_dynamic_exec_lib(int client_fd, char* resource_name)$/;"	f
handle_static	util.c	/^void handle_static(int fd, char* resource_name)$/;"	f
handler_t	csapp.h	/^typedef void handler_t(int);$/;"	t
head	cache.h	/^    cache_entry_t* head;$/;"	m	struct:cache
header_key_value	http_header.h	/^typedef struct header_key_value$/;"	s
header_kv_pair_t	http_header.h	/^}header_kv_pair_t;$/;"	t	typeref:struct:header_key_value
host	http_header.h	/^    char host[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
http_header	http_header.h	/^typedef struct http_header$/;"	s
http_header_t	http_header.h	/^}http_header_t;$/;"	t	typeref:struct:http_header
http_scan_header	http_util.c	/^int http_scan_header(int clientfd, http_header_t* header)$/;"	f
http_write_response_header	http_util.c	/^int http_write_response_header(int clientfd, int http_response_code)$/;"	f
increase_fd_limit	util.c	/^int increase_fd_limit(int max_fds)$/;"	f
increment_reply_count	util.c	/^void increment_reply_count()$/;"	f
increment_request_count	util.c	/^void increment_request_count()$/;"	f
init_header	http_header.c	/^void init_header(http_header_t* header)$/;"	f
init_library	util.c	/^void init_library()$/;"	f
key	cache.h	/^    cache_key_t key;$/;"	m	struct:cache_data_item
key	http_header.h	/^    char key[MAX_HEADER_KEY_LENGTH];$/;"	m	struct:header_key_value
key_data	cache.h	/^    char key_data[MAX_KEY_LENGTH]; \/* Name of the library file *\/$/;"	m	struct:cache_key
library_eviction_callback	util.c	/^void library_eviction_callback(cache_data_item_t* item)$/;"	f
load_dyn_library	dynlib.c	/^void* load_dyn_library(char* library_name)$/;"	f
load_dyn_library	util.c	/^void* load_dyn_library(char* library_name)$/;"	f
lock	cache.h	/^    pthread_rwlock_t lock;$/;"	m	struct:cache
lock	cache.h	/^    pthread_rwlock_t lock;$/;"	m	struct:cache_entry
main	cache_test.c	/^int main()$/;"	f
main	cgi-bin/src/hash.c	/^int main()$/;"	f
main	cgi-bin/src/hello_unopt.c	/^int main()$/;"	f
main	cgi-bin/src/random_unopt.c	/^int main()$/;"	f
main	cgi-bin/src/string_unopt.c	/^int main()$/;"	f
main	cgi-bin/src/time_long_unopt.c	/^int main()$/;"	f
main	cgi-bin/src/time_really_long_unopt.c	/^int main(){$/;"	f
main	cgi-bin/src/time_unopt.c	/^int main()$/;"	f
main	server.c	/^int main(int argc, char *argv[])$/;"	f
main	server_unopt.c	/^int main(int argc, char *argv[])$/;"	f
make_socket_non_blocking	util.c	/^int make_socket_non_blocking (int sfd)$/;"	f
next	cache.h	/^    struct cache_entry* next;$/;"	m	struct:cache_entry	typeref:struct:cache_entry::cache_entry
next	http_header.h	/^    struct header_key_value* next;$/;"	m	struct:header_key_value	typeref:struct:header_key_value::header_key_value
open_clientfd	csapp.c	/^int open_clientfd(char *hostname, char *port) {$/;"	f
open_listenfd	csapp.c	/^int open_listenfd(char *port)$/;"	f
other_headers	http_header.h	/^    header_kv_pair_t *other_headers;$/;"	m	struct:http_header
parse_port_number	util.c	/^int parse_port_number(int argc, char* argv)$/;"	f
posix_error	csapp.c	/^void posix_error(int code, char *msg) \/* Posix-style error *\/$/;"	f
prev	cache.h	/^    struct cache_entry* prev;$/;"	m	struct:cache_entry	typeref:struct:cache_entry::cache_entry
projects	static/vamshi.html	/^<h2><a name="projects">Projects<\/a><\/h2>$/;"	a
proxy_connection	http_header.h	/^    char proxy_connection[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
reply_cnt	util.c	/^static long reply_cnt = 0;$/;"	v	file:
replycnt_mutex	util.c	/^static pthread_mutex_t replycnt_mutex;$/;"	v	file:
request_cnt	util.c	/^static long request_cnt = 0;$/;"	v	file:
request_http_version	http_header.h	/^    char request_http_version[MAX_HTTP_VERSION_LENGTH]; \/* HTTP\/1.1, HTTP\/1.0 *\/$/;"	m	struct:http_header
request_item	util.h	/^typedef struct request_item$/;"	s
request_item	util.h	/^}request_item;$/;"	t	typeref:struct:request_item
request_type	http_header.h	/^    char request_type[MAX_REQUEST_TYPE_LENGTH]; \/* GET *\/$/;"	m	struct:http_header
request_url	http_header.h	/^    char request_url[MAX_URL_LENGTH]; \/* \/, \/index.html, etc *\/$/;"	m	struct:http_header
resource_name	util.h	/^    char resource_name[MAX_RESOURCE_NAME_LENGTH];$/;"	m	struct:request_item
rio_buf	csapp.h	/^    char rio_buf[RIO_BUFSIZE]; \/* Internal buffer *\/$/;"	m	struct:__anon1
rio_bufptr	csapp.h	/^    char *rio_bufptr;          \/* Next unread byte in internal buf *\/$/;"	m	struct:__anon1
rio_cnt	csapp.h	/^    int rio_cnt;               \/* Unread bytes in internal buf *\/$/;"	m	struct:__anon1
rio_fd	csapp.h	/^    int rio_fd;                \/* Descriptor for this internal buf *\/$/;"	m	struct:__anon1
rio_read	csapp.c	/^static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n)$/;"	f	file:
rio_readinitb	csapp.c	/^void rio_readinitb(rio_t *rp, int fd)$/;"	f
rio_readlineb	csapp.c	/^ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen)$/;"	f
rio_readn	csapp.c	/^ssize_t rio_readn(int fd, void *usrbuf, size_t n)$/;"	f
rio_readnb	csapp.c	/^ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n)$/;"	f
rio_t	csapp.h	/^} rio_t;$/;"	t	typeref:struct:__anon1
rio_writen	csapp.c	/^ssize_t rio_writen(int fd, void *usrbuf, size_t n)$/;"	f
send_to_worker_thread	util.c	/^int send_to_worker_thread(request_item* reqitem)$/;"	f
sio_error	csapp.c	/^void sio_error(char s[]) \/* Put error message and exit *\/$/;"	f
sio_ltoa	csapp.c	/^static void sio_ltoa(long v, char s[], int b)$/;"	f	file:
sio_putl	csapp.c	/^ssize_t sio_putl(long v) \/* Put long *\/$/;"	f
sio_puts	csapp.c	/^ssize_t sio_puts(char s[]) \/* Put string *\/$/;"	f
sio_reverse	csapp.c	/^static void sio_reverse(char s[])$/;"	f	file:
sio_strlen	csapp.c	/^static size_t sio_strlen(char s[])$/;"	f	file:
static_content_worker_thread	server.c	/^void* static_content_worker_thread(void* arg)$/;"	f
statistics_thread	util.c	/^void* statistics_thread(void* arg)$/;"	f
tcp	static/vamshi.html	/^<p><strong><a target="blank" href="https:\/\/github.com\/vamshireddy\/TCP-SawTooth-Peformance-Measurement">TCP Sawtooth Peformance Measurement<\/a><\/strong>: I have measured the peformance of TCP congestion window in Parking lot topology. This experiment shows various plots for bandwidth sharing and the congestion windows of all the senders present in the topology.<a name="tcp" href="https:\/\/www.usenix.org\/conference\/nsdi12\/technical-sessions\/presentation\/prakash">TCP outcast<\/a> problem in data centers is also demonstrated along with this project, on Mininet.<\/p>$/;"	a
timestamp	cache.h	/^    struct timeval timestamp;$/;"	m	struct:cache_entry	typeref:struct:cache_entry::timeval
total_size	cache.h	/^    long total_size; \/* total size of the cache in bytes *\/$/;"	m	struct:cache
type	util.h	/^    int type; \/* Who is owner of this state *\/$/;"	m	struct:epoll_conn_state
unix_error	csapp.c	/^void unix_error(char *msg) \/* Unix-style error *\/$/;"	f
unload_dyn_library	dynlib.c	/^int unload_dyn_library(void* handle)$/;"	f
user_agent	http_header.h	/^    char user_agent[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:http_header
value	cache.h	/^    cache_value_t value;$/;"	m	struct:cache_data_item
value	http_header.h	/^    char value[MAX_HEADER_VALUE_LENGTH];$/;"	m	struct:header_key_value
value_data	cache.h	/^    void* value_data;$/;"	m	struct:cache_value
worker_fd	util.h	/^    int worker_fd; \/* Assigned workerfd for the client's fd *\/$/;"	m	struct:epoll_conn_state
